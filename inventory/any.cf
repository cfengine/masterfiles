bundle common inventory_any
# @brief Do inventory for any OS
#
# This common bundle is for any OS work not handled by specific
# bundles.
{
}

bundle agent inventory_autorun
# @brief Autorun some inventory bundles
#
# This agent bundle runs other "autorun" inventory agent bundles
# explicitly.  It will use bundlesmatching() when CFEngine 3.5 and
# earlier are no longer supported.
{
  methods:
    !disable_inventory_cmdb::
      "cmdb" usebundle => cfe_autorun_inventory_cmdb(),
      handle => "cfe_internal_autorun_inventory_cmdb";

    !disable_inventory_LLDP::
      "LLDP" usebundle => cfe_autorun_inventory_LLDP(),
      handle => "cfe_internal_autorun_inventory_LLDP";

    !disable_inventory_package_refresh::
      "packages_refresh" usebundle => cfe_autorun_inventory_packages(),
      handle => "cfe_internal_autorun_inventory_packages";

    !disable_inventory_proc::
      "proc" usebundle => cfe_autorun_inventory_proc(),
      handle => "cfe_internal_autorun_inventory_proc";

    !disable_inventory_fstab::
      "fstab" usebundle => cfe_autorun_inventory_fstab(),
      handle => "cfe_internal_autorun_inventory_fstab";

    !disable_inventory_mtab::
      "mtab" usebundle => cfe_autorun_inventory_mtab(),
      handle => "cfe_internal_autorun_inventory_mtab";

    !disable_inventory_dmidecode::
      "dmidecode" usebundle => cfe_autorun_inventory_dmidecode(),
      handle => "cfe_internal_autorun_inventory_dmidecode";

    !disable_inventory_local_users_discover::
      "local_users" usebundle => cfe_autorun_inventory_local_users_discover(),
      handle => "cfe_internal_autorun_discovery_local_users";

    !disable_inventory_local_users::
      "local_users_locked" usebundle => inventory_local_users(),
      handle => "cfe_internal_autorun_inventory_local_users";

    !disable_inventory_local_users_locked::
      "local_users_locked" usebundle => inventory_local_users_locked(),
      handle => "cfe_internal_autorun_inventory_local_users_locked";

    !disable_inventory_local_users_password_last_change::
      "local_users_password_last_change" usebundle => inventory_local_users_password_last_change(),
      handle => "cfe_internal_autorun_inventory_local_users_password_last_change";

    !disable_inventory_local_users_password_empty::
      "local_users_password_empty" usebundle => inventory_local_users_password_empty(),
      handle => "cfe_internal_autorun_inventory_local_users_password_empty";

    any::
      "listening ports" usebundle => cfe_autorun_inventory_listening_ports(),
      handle => "cfe_internal_autorun_listening_ports";

      "disk" usebundle => cfe_autorun_inventory_disk(),
      handle => "cfe_internal_autorun_disk";

      "memory" usebundle => cfe_autorun_inventory_memory(),
      handle => "cfe_internal_autorun_memory";

      "loadaverage" usebundle => cfe_autorun_inventory_loadaverage(),
      handle => "cfe_internal_autorun_loadaverage";
}

bundle agent cfe_autorun_inventory_listening_ports
# @brief Inventory the listening ports
#
# This bundle uses `mon.listening_ports` and is always enabled by
# default, as it runs instantly and has no side effects.
{
  vars:
      "ports" slist => sort( "mon.listening_ports", "int"),
      meta => { "inventory", "attribute_name=Ports listening" };
}

bundle agent cfe_autorun_inventory_disk
# @brief Inventory the disk (Enterprise only)
{
  vars:
    enterprise::
      "free" string => "$(mon.value_diskfree)",
               meta => { "inventory", "attribute_name=Disk free (%)" };
}

bundle agent cfe_autorun_inventory_memory
# @brief Inventory the memory (Enterprise only)
{
  vars:
    enterprise::
      # due to a Windows issue this is set to 0 there for now
      "total" string => ifelse("windows", "0",
                               $(mon.value_mem_total)),
      meta => { "inventory", "attribute_name=Memory size (MB)" };

      "free" string => ifelse("windows", "0",
                              $(mon.value_mem_free)),
      meta => { "report" };
}

bundle agent cfe_autorun_inventory_loadaverage
# @brief Inventory the loadaverage (Enterprise only)
{
  vars:
    enterprise::
      "value" string => "$(mon.value_loadavg)",
      meta => { "report" };
}

bundle agent cfe_autorun_inventory_proc
# @brief Do procfs inventory
#
# This bundle will parse these /proc files: consoles, cpuinfo,
# meminfo, modules, partitions, version, vmstat.  There are
# some general patterns you can follow to extend it for other /proc
# items of interest.
#
# Contributions welcome.  /proc/net and /proc/sys in general are of
# wide interest, if you're looking for something fun.  For instance,
# the network interfaces could be extracted here without calling
# `ifconfig`.
{
  vars:
      "basefiles" slist => { "consoles", "cpuinfo", "modules", "partitions", "version" };
      "files[$(basefiles)]" string => "$(inventory_control.proc)/$(basefiles)";

    _have_proc_consoles::
      "console_count" int =>  readstringarrayidx("consoles",
                                                 "$(files[consoles])",
                                                 "\s*#[^\n]*",
                                                 "\s+",
                                                 500,
                                                 50000);

      "console_idx" slist => getindices("consoles");

    _have_proc_modules::
      "module_count" int =>  readstringarrayidx("modules",
                                                "$(files[modules])",
                                                "\s*#[^\n]*",
                                                "\s+",
                                                2500,
                                                250000);

      "module_idx" slist => getindices("modules");

    _have_proc_cpuinfo::
      # this will extract all the keys in one bunch, so you won't get
      # detailed info for processor 0 for example
      "cpuinfo_count" int =>  readstringarrayidx("cpuinfo_array",
                                                 "$(files[cpuinfo])",
                                                 "\s*#[^\n]*",
                                                 "\s*:\s*",
                                                 500,
                                                 50000);

      "cpuinfo_idx" slist => getindices("cpuinfo_array");
      "cpuinfo[$(cpuinfo_array[$(cpuinfo_idx)][0])]" string => "$(cpuinfo_array[$(cpuinfo_idx)][1])";
      "cpuinfo_keys" slist => getindices("cpuinfo");

    _have_proc_partitions::
      "partitions_count" int =>  readstringarrayidx("partitions_array",
                                                    "$(files[partitions])",
                                                    "major[^\n]*",
                                                    "\s+",
                                                    500,
                                                    50000);

      "partitions_idx" slist => getindices("partitions_array");
      "partitions[$(partitions_array[$(partitions_idx)][4])]" string => "$(partitions_array[$(partitions_idx)][3])";
      "partitions_keys" slist => getindices("partitions");

    _have_proc_version::
      "version" string => readfile("$(files[version])", 2048);

  classes:
      "have_proc" expression => isdir($(inventory_control.proc));

    have_proc::
      "_have_proc_$(basefiles)"
      expression => fileexists("$(files[$(basefiles)])");

    _have_proc_consoles::
      "have_console_$(consoles[$(console_idx)][0])"
      expression => "any",
      scope => "namespace";

    _have_proc_modules::
      "have_module_$(modules[$(module_idx)][0])"
      expression => "any",
      scope => "namespace";

  reports:
    _have_proc_consoles.verbose_mode::
      "$(this.bundle): we have console $(consoles[$(console_idx)][0])";
    _have_proc_modules.verbose_mode::
      "$(this.bundle): we have module $(modules[$(module_idx)][0])";
    _have_proc_cpuinfo.verbose_mode::
      "$(this.bundle): we have cpuinfo $(cpuinfo_keys) = $(cpuinfo[$(cpuinfo_keys)])";
    _have_proc_partitions.verbose_mode::
      "$(this.bundle): we have partitions $(partitions_keys) with $(partitions[$(partitions_keys)]) blocks";
    _have_proc_version.verbose_mode::
      "$(this.bundle): we have kernel version '$(version)'";
}

bundle agent cfe_autorun_inventory_mtab
# @brief Do mtab inventory
#
# The mtab format is simple: each line looks like this format:
# `/dev/sda1 / ext4 rw,noatime,data=ordered 0 0` (in order: `DEV
# MOUNTPOINT FSTYPE OPTIONS DUMP-FREQ PASS`).  Some older Unices have
# a different format and it's really not portable, so enable this only
# if you know you want it.  It's very handy if you want to check if a
# file system is mounted.
{
  vars:
    have_mtab::
      "mount_count" int =>  readstringarrayidx("mounts",
                                               $(inventory_control.mtab),
                                               "\s*#[^\n]*",
                                               "\s+",
                                               500,
                                               50000);

      "idx" slist => getindices("mounts");

  classes:
      "have_mtab" expression => fileexists($(inventory_control.mtab));

      # define classes like have_mount_ext4__var for a ext4 /var mount
      "have_mount_$(mounts[$(idx)][2])_$(mounts[$(idx)][1])"
      expression => "any",
      scope => "namespace";

      # define classes like have_mount_ext4 if there is a ext4 mount
      "have_mount_$(mounts[$(idx)][2])"
      expression => "any",
      scope => "namespace";

  reports:
    verbose_mode::
      "$(this.bundle): we have a $(mounts[$(idx)][2]) mount under $(mounts[$(idx)][1])";
}

bundle agent cfe_autorun_inventory_fstab
# @brief Do fstab inventory
#
# The fstab format is simple: each line looks like this format:
# `/dev/sda1 / auto noatime 0 1` (in order: `DEV MOUNTPOINT FSTYPE
# OPTIONS DUMP-FREQ PASS`).  Note the FSTYPE is not known from the
# fstab.
#
# Solaris has 'MOUNTDEV FSCKDEV MOUNTPOINT FSTYPE PASS MOUNT-AD-BOOT
# OPTIONS' but is not supported here.  Contributions welcome.
{
  vars:
    have_fstab::
      "mount_count" int =>  readstringarrayidx("mounts",
                                               $(sys.fstab),
                                               "\s*#[^\n]*",
                                               "\s+",
                                               500,
                                               50000);

      "idx" slist => getindices("mounts");

  classes:
      "have_fstab" expression => fileexists($(sys.fstab));

      # define classes like have_fs_ext4__var for a ext4 /var entry
      "have_fs_$(mounts[$(idx)][2])_$(mounts[$(idx)][1])"
      expression => "any",
      scope => "namespace";

      # define classes like have__var for a /var entry
      "have_fs_$(mounts[$(idx)][1])"
      expression => "any",
      scope => "namespace";

      # define classes like have_fs_ext4 if there is a ext4 entry
      "have_fs_$(mounts[$(idx)][2])"
      expression => "any",
      scope => "namespace";

  reports:
    verbose_mode::
      "$(this.bundle): we have a $(mounts[$(idx)][2]) fstab entry under $(mounts[$(idx)][1])";
}

bundle agent cfe_autorun_inventory_dmidecode
# @brief Do dmidecode-based inventory
#
# This common bundle runs dmidecode
{
  vars:
      "dmidefs" data => parsejson('
{
  "bios-vendor": "BIOS vendor",
  "bios-version": "BIOS version",
  "system-serial-number": "System serial number",
  "system-manufacturer": "System manufacturer",
  "system-version": "System version",
  "processor-version": "CPU model"
}');

      # other dmidecode variables you may want:
      # baseboard-asset-tag
      # baseboard-manufacturer
      # baseboard-product-name
      # baseboard-serial-number
      # baseboard-version
      # bios-release-date
      # chassis-asset-tag
      # chassis-manufacturer
      # chassis-serial-number
      # chassis-type
      # chassis-version
      # processor-family
      # processor-frequency
      # processor-manufacturer
      # system-product-name
      # system-uuid

      "dmivars" slist => getindices(dmidefs);

    have_dmidecode::
      "decoder" string => "$(inventory_control.dmidecoder)";

    have_dmidecode.!(redhat_4|redhat_3)::
      "dmi[$(dmivars)]" string => execresult("$(decoder) -s $(dmivars)",
                                             "useshell"),
      meta => { "inventory", "attribute_name=$(dmidefs[$(dmivars)])" };

    windows.powershell::
      "dmi[bios-vendor]" string => $(bios_array[1]),
      meta => { "inventory", "attribute_name=BIOS vendor" };

      "dmi[system-serial-number]" string => $(bios_array[2]),
      meta => { "inventory", "attribute_name=System serial number" };

      "dmi[bios-version]" string => $(bios_array[3]),
      meta => { "inventory", "attribute_name=BIOS version" };

      "dmi[system-version]" string => $(bios_array[4]),
      meta => { "inventory", "attribute_name=System version" };

      "dmi[processor-version]" string => $(processor_array[1]),
      meta => { "inventory", "attribute_name=CPU model" };
 
      "split_pscomputername"
        slist => string_split($(system_array[1]), "PSComputerName\s.*", 2),
        comment => "Work around weird appearance of PSComputerName into System manufacturer";

      "dmi[system-manufacturer]" string => nth(split_pscomputername, 0),
      meta => { "inventory", "attribute_name=System manufacturer" };

  classes:
      "have_dmidecode" expression => fileexists($(inventory_control.dmidecoder));

    windows.powershell::
      "bios_match" expression => regextract(".*Manufacturer\s+:\s([a-zA-Z0-9 ]+)\n.*SerialNumber\W+([a-zA-Z0-9 ]+).*SMBIOSBIOSVersion\W+([a-zA-Z0-9 ]+).*Version\W+([a-zA-Z0-9 -]+)",
                                            execresult("gwmi -query 'SELECT SMBIOSBIOSVersion, Manufacturer, SerialNumber, Version FROM WIN32_BIOS'", "powershell"),
                                            "bios_array");

      "processor_match" expression => regextract(".*Name\W+(.*)",
                                                 execresult("gwmi -query 'SELECT Name FROM WIN32_PROCESSOR'", "powershell"),
                                                 "processor_array");

      "system_match" expression => regextract(".*Manufacturer\W+(.*)",
                                              execresult("gwmi -query 'SELECT Manufacturer FROM WIN32_COMPUTERSYSTEM'", "powershell"),
                                              "system_array");

  reports:
    inform_mode::
      "$(this.bundle): Obtained $(dmidefs[$(dmivars)]) = '$(dmi[$(dmivars)])'";
}

bundle agent cfe_autorun_inventory_LLDP
# @brief Do LLDP-based inventory
#
# This agent bundle runs lldpctl to discover information.  See
# http://vincentbernat.github.io/lldpd/ to run this yourself for
# testing, and your Friendly Network Admin may be of help too.
{
  classes:
      "disable_inventory_LLDP" not => fileexists($(inventory_control.lldpctl_exec));

  commands:
    !disable_inventory_LLDP::
      "$(inventory_control.lldpctl_exec) | perl -n -e 'my ($k, $v) = m/([^=]+)=(.*)/; $k =~ s/\W/_/g; print \"=$k=$v\";"
      classes => kept_successful_command,
      module => "true";
}

bundle agent cfe_autorun_inventory_packages
# @brief Package inventory auto-refresh
#
# This bundle is for refreshing the package inventory.  It runs on
# startup, unless disabled.  Other package methods can be added below.
{
  classes:
      "have_patches" or => { "community_edition", # not in Community
                             fileexists("$(sys.workdir)/state/software_patches_avail.csv") };

      "have_inventory" and => { "have_patches",
                                fileexists("$(sys.workdir)/state/software_packages.csv"),
      };

  vars:
      # if we have the patches, 7 days; otherwise keep trying
      "refresh" string => ifelse("have_inventory", "10080",
                                 "0");

  packages:
    debian::
      "cfe_internal_non_existing_package"
      package_policy => "add",
      package_method => inventory_apt_get($(refresh)),
      action => if_elapsed_day;

    redhat::
      "cfe_internal_non_existing_package"
      package_policy => "add",
      package_method => inventory_yum_rpm($(refresh)),
      action => if_elapsed_day;

    suse::
      "cfe_internal_non_existing_package"
      package_policy => "add",
      package_method => inventory_zypper($(refresh)),
      action => if_elapsed_day;

    aix::
      "cfe_internal_non_existing_package"
      package_policy => "add",
      package_method => inventory_lslpp($(refresh)),
      action => if_elapsed_day;

    gentoo::
      "cfe_internal_non_existing_package"
      package_policy => "add",
      package_method => emerge,
      action => if_elapsed_day;

    !redhat.!debian.!gentoo.!suse.!aix::
      "cfe_internal_non_existing_package"
      package_policy => "add",
      package_method => generic,
      action => if_elapsed_day;

  reports:
    inform_mode::
      "$(this.bundle): refresh interval is $(refresh)";
    inform_mode.have_inventory::
      "$(this.bundle): we have the inventory files.";
    inform_mode.!have_inventory::
      "$(this.bundle): we don't have the inventory files.";
}

body package_method inventory_apt_get(update_interval)
# @depends debian_knowledge
# @brief APT installation package method for inventory purposes only
# @param update_interval how often to update the package and patch list
#
# This package method is a copy of the yum_rpm method just for
# inventory purposes.
#
# This package method interacts with the APT package manager through
# `apt-get`.  It will never run "apt-get update" but is otherwise
# exactly like the `apt_get` package method and *may* use the network
# to install packages, as APT may decide.
{
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex => "$(debian_knowledge.list_name_regex)";
      package_list_version_regex => "$(debian_knowledge.list_version_regex)";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)=$(version)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_ifelapsed => $(update_interval);

      # Target a specific release, such as backports
      package_add_command => "$(debian_knowledge.call_apt_get) --help >/dev/null 2>&1 ; /bin/true";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "$(debian_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(debian_knowledge.patch_version_regex)";

      # make correct version comparisons
      package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
      package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";
}

body package_method inventory_yum_rpm(update_interval)
# @depends common_knowledge redhat_knowledge rpm_knowledge
# @brief Yum+RPM installation method for inventory purposes only
# @param update_interval how often to update the package and patch list
#
# This package method is a copy of the yum_rpm method just for
# inventory purposes.
#
# It will never run "yum update" but is otherwise exactly like the
# `yum_rpm()` package method and *may* use the network to install
# packages, as Yum may decide.
{
      package_changes => "bulk";
      package_list_command => "$(rpm_knowledge.call_rpm) -qa --qf '$(rpm_knowledge.rpm3_output_format)'";
      package_patch_list_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_offline_options) check-update $(redhat_knowledge.check_update_postproc)";

      package_list_name_regex    => "$(rpm_knowledge.rpm3_name_regex)";
      package_list_version_regex => "$(rpm_knowledge.rpm3_version_regex)";
      package_list_arch_regex    => "$(rpm_knowledge.rpm3_arch_regex)";

      package_installed_regex => ".*";
      package_name_convention => "$(name)-$(version).$(arch)";

      # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
      package_delete_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) check-update $(redhat_knowledge.check_update_postproc)";
      package_list_update_ifelapsed => $(update_interval);

      package_patch_name_regex    => "$(redhat_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(redhat_knowledge.patch_version_regex)";
      package_patch_arch_regex    => "$(redhat_knowledge.patch_arch_regex)";

      package_add_command    => "$(redhat_knowledge.call_yum) --help >/dev/null 2>&1 ; /bin/true";
      package_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_patch_command  => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_delete_command => "$(rpm_knowledge.call_rpm) -e --nodeps";
      package_verify_command => "$(rpm_knowledge.call_rpm) -V";
}

body package_method inventory_lslpp(update_interval)
# @brief AIX lslpp installation method for inventory purposes only
# @param update_interval how often to update the package and patch list
{
      package_changes => "individual";

      package_list_update_command => "/usr/bin/true";
      package_list_update_ifelapsed => $(update_interval);

      package_list_command       => "/usr/bin/lslpp -Lqc"; # list RPMs too
      package_list_name_regex    => "([^:]+):.*";
      package_list_version_regex => "[^:]+:[^:]+:([^:]+):.*";
      package_installed_regex    => "[^:]+:[^:]+:[^:]+:[^:]+:[^:]+:([CA]):.*";

      package_name_convention    => "$(name)-$(version).+";

      package_add_command    => "/usr/bin/true";
      package_update_command => "/usr/bin/true";
      package_patch_command  => "/usr/bin/true";
      package_delete_command => "/usr/bin/true";
      package_verify_command => "/usr/bin/true";
}

body package_method inventory_zypper(update_interval)
# @depends common_knowledge rpm_knowledge suse_knowledge
# @brief SUSE zypper installation method for inventory purposes only
# @param update_interval how often to update the package and patch list
#
# This package method is a copy of the SUSE zypper method just for
# inventory purposes.
{
      package_changes => "bulk";

      package_list_command => "$(paths.path[rpm]) -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(suse_knowledge.call_zypper) list-updates";
      package_list_update_ifelapsed => $(update_interval);

      package_patch_list_command => "$(suse_knowledge.call_zypper) patches";
      package_installed_regex => "i.*";
      package_list_name_regex    => "$(rpm_knowledge.rpm_name_regex)";
      package_list_version_regex => "$(rpm_knowledge.rpm_version_regex)";
      package_list_arch_regex    => "$(rpm_knowledge.rpm_arch_regex)";

      package_patch_installed_regex => ".*Installed.*|.*Not Applicable.*";
      package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
      package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";

      package_name_convention => "$(name)";
      package_add_command => "$(suse_knowledge.call_zypper) --help >/dev/null 2>&1 ; /bin/true";
      package_delete_command => "$(suse_knowledge.call_zypper) --non-interactive remove --force-resolution";
      package_update_command => "$(suse_knowledge.call_zypper) --non-interactive update";
      package_patch_command => "$(suse_knowledge.call_zypper) --non-interactive patch$"; # $ means no args
      package_verify_command => "$(suse_knowledge.call_zypper) --non-interactive verify$";
}

bundle agent cfe_autorun_inventory_cmdb
# @brief Copy and load the CMDB inventory
#
# This bundle is for refreshing the CMDB inventory.  It copies the
# file me.json from the server, then loads it to create variables and
# classes.
{
  vars:
      "cmdb_dir" string => "$(sys.workdir)/cmdb",
      comment => "CMDB directory location",
      meta => { "cmdb" };

      "cmdb_file" string => "$(cmdb_dir)/me.json",
      comment => "CMDB file location",
      meta => { "cmdb" };

  files:
      "$(cmdb_file)"
      copy_from => inventory_cmdb_copy_from,
      classes => inventory_scoped_classes_generic("bundle", "cmdb_file");

  methods:
    cmdb_file_ok::
      "load CMDB file" usebundle => inventory_cmdb_load($(cmdb_file));
}

bundle agent inventory_cmdb_load(file)
# @brief Load the CMDB inventory
#
# This bundle is for loading the CMDB inventory.
{
  classes:
      "have_cmdb_data" expression => isvariable("cmdb");

      "$(ckeys)" expression => "any", scope => "namespace";

  vars:
      "cmdb" data => readjson($(file), "999999");
      "cmdb_string" string => format("%S", cmdb);

      "bkeys" slist => getindices("cmdb[vars]");
      "vkeys_$(bkeys)" slist => getindices("cmdb[vars][$(bkeys)]");
      "$(vkeys_$(bkeys))" string => nth("cmdb[vars][$(bkeys)]", $(vkeys));

      "ckeys" slist => getindices("cmdb[classes]");

  reports:
    inform_mode.have_cmdb_data::
      "$(this.bundle): Got CMDB data from $(file): $(cmdb_string)";
    verbose_mode.have_cmdb_data::
      "$(this.bundle): Got CMDB key = $(vkeys_$(bkeys)), CMDB value = $((vkeys_$(bkeys)))";
      "$(this.bundle): Got CMDB class = $(ckeys)";
    inform_mode.!have_cmdb_data::
      "$(this.bundle): Could not read the CMDB data from $(file)";
}

bundle agent cfe_autorun_inventory_local_users_discover
# @brief Discover local user information
#
# This bundle does local user discovery by parsing /etc/passwd and /etc/shadow
# on linux and unix systems. The variables populated by this discovery are
# reported back to Mission Portal, but they are not inventoried by default.
# The companion bundles inventory_local_users_* if enabled will report the
# variables with inventory tags to populate the inventory.
#
# **See Also:**
# * `inventory_local_users_password_last_change`
# * `inventory_local_users`
# * `inventory_local_users_locked`
# * `inventory_local_users_password_empty`
{
  vars:
    linux::
      "shadow_data" data => data_readstringarray("$(paths.shadow)", "", ":", 500, 10240);
      "passwd_data" data => data_readstringarray("/etc/passwd", "", ":", 500, 10240);


      "all_local_users"
        slist => getindices("passwd_data"),
        meta => { "report" };

      "all_local_users_str"
        string => join(", ", all_local_users),
        comment => "Having a combined string of users is useful for debug reports";

      "all_local_users_canonified_map[$(all_local_users)]"
        string => canonify($(all_local_users));

      "all_local_users_canonified_list"
        slist => maplist("$(local_users_canonified_list[$(this)])", "local_users"),
        comment => "A canonified list is useful when dealing with variables
                    because user names may contain characters that are invalid
                    in variable names";

      "date_last_password_change[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][1])",
        meta => { "report", "derived_from=$(paths.shadow)" };

      "min_password_age[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][2])",
        meta => { "report", "derived_from=$(paths.shadow)" };

      "max_password_age[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][3])",
        meta => { "report", "derived_from=$(paths.shadow)" };

      "password_warning_period[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][4])",
        meta => { "report", "derived_from=$(paths.shadow)" };

      "password_inactivity_period[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][5])",
        meta => { "report", "derived_from=$(paths.shadow)" };

      "account_expiration_date[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][6])",
        meta => { "report", "derived_from=$(paths.shadow)" };

      "numeric_user_id[$(all_local_users)]"
        string => "$(passwd_data[$(all_local_users)][1])",
        meta => { "report", "derived_from=/etc/passwd" };

      "numeric_group_id[$(all_local_users)]"
        string => "$(passwd_data[$(all_local_users)][2])",
        meta => { "report", "derived_from=/etc/passwd" };

      "comment[$(all_local_users)]"
        string => "$(passwd_data[$(all_local_users)][3])",
        meta => { "report", "derived_from=/etc/passwd" };

      "home_directory[$(all_local_users)]"
        string => "$(passwd_data[$(all_local_users)][4])",
        meta => { "report", "derived_from=/etc/passwd" };

      "shell[$(all_local_users)]"
        string => "$(passwd_data[$(all_local_users)][5])",
        meta => { "report", "derived_from=/etc/passwd" };

    linux.!disable_inventory_local_users_discover_report_encrypted_password::
      "encrypted_password[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][0])",
        meta => { "report" };

    linux.disable_inventory_local_users_discover_report_encrypted_password::
      "encrypted_password[$(all_local_users)]"
        string => "$(shadow_data[$(all_local_users)][0])";

  classes:
    linux::
      "$(all_local_users)_password_locked"
        expression => regcmp( "^!.*", "$(encrypted_password[$(all_local_users)])" ),
        scope => "namespace",
        meta => { "report" },
        comment => "A password field starting with exclimation point is a locked account";

      "$(all_local_users)_password_empty"
        expression => regcmp( "", "$(encrypted_password[$(all_local_users)])" ),
        scope => "namespace",
        meta => { "report" },
        comment => "An empty password field may allow passwordless login, it
                    depends on the application reading the shadow file.";

      "$(all_local_users)_password_valid_hash"
        expression => regcmp( "\Q$\E(1|2a|5|6)\$.*", "$(encrypted_password[$(all_local_users)])" ),
        scope => "namespace",
        meta => { "report" },
        comment => "If the hashed password matches this regex then we think we
                    have a valid password hash. Note: It may or may not be
                    valid for the speicifc platform. For example EL5 does not
                    support sha512 hashed passwords (hashes starting with $6$).";

      "$(all_local_users)_password_invalid_hash"
        not => "$(all_local_users_canonified_map[$(all_local_users)])_password_valid_hash",
        scope => "namespace",
        meta => { "report" },
        comment => "If the password has is not valid it must be invalid. This
                    could mean locked, empty or otherwise invalid.";

  reports:
    inform_mode|verbose_mode::
      "$(this.bundle): Discovered: '$(all_local_users_str)'";
      "$(this.bundle): Last Password Change Date: '$(all_local_users)'='$(date_last_password_change[$(all_local_users)])'";
      "$(this.bundle): Min Password Age: '$(all_local_users)'='$(min_password_age[$(all_local_users)])'";
      "$(this.bundle): Max Password Age: '$(all_local_users)'='$(max_password_age[$(all_local_users)])'";
      "$(this.bundle): Password Warning Period: '$(all_local_users)'='$(password_warning_period[$(all_local_users)])'";
      "$(this.bundle): Password Inactivity Period: '$(all_local_users)'='$(password_inactivity_period[$(all_local_users)])'";
      "$(this.bundle): Account Expiration Date: '$(all_local_users)'='$(account_expiration_date[$(all_local_users)])'";
      "$(this.bundle): Numeric User ID: '$(all_local_users)'='$(numeric_user_id[$(all_local_users)])'";
      "$(this.bundle): Username/Comment: '$(all_local_users)'='$(comment[$(all_local_users)])'";
      "$(this.bundle): Home Directory: '$(all_local_users)'='$(home_directory[$(all_local_users)])'";
      "$(this.bundle): Shell: '$(all_local_users)'='$(shell[$(all_local_users)])'";

      "$(this.bundle): '$(all_local_users)' account is locked"
        ifvarclass => "$(all_local_users_canonified_list)_password_locked";

      "$(this.bundle): '$(all_local_users)' password is empty"
        ifvarclass => "$(all_local_users_canonified_map[$(all_local_users)])_password_empty";

      "$(this.bundle): '$(all_local_users)' password appears valid"
        ifvarclass => "$(all_local_users_canonified_map[$(all_local_users)])_password_valid_hash";

      "$(this.bundle): '$(all_local_users)' password appears invalid"
        ifvarclass => "$(all_local_users_canonified_map[$(all_local_users)])_password_invalid_hash";
}

bundle agent inventory_local_users
# @brief Inventory local users on the system
#
# This bundle reports back the inventory of local users as discovered in
# `cfe_autorun_inventory_local_users_discover`.
# **See Also:**
# * `inventory_local_users_password_last_change`
# * `inventory_local_users_locked`
# * `inventory_local_users_password_empty`

{
  vars:
    linux::
      "local_users"
        slist => { @(cfe_autorun_inventory_local_users_discover.all_local_users) },
        meta => {
                  "inventory",
                  "attribute_name=Local users",
                  "derived_from=bundle:cfe_autorun_inventory_local_users_discover",
                };

  reports:
    inform_mode|verbose_mode::
      "$(this.bundle): Adding $(local_users) to Local User Inventory";
}

bundle agent inventory_local_users_locked
# @brief Inventory local user accounts that are locked (have ! as the first
# character of the hashed passwword field)
#
# This bundle inventories local user accounts that appear to be locked as
# discovered in `cfe_autorun_inventory_local_users_discover`. An account is
# considered locked if the first character of the encrypted password field in
# $(paths.shadow) is '!'.
#
# **See Also:**
# * `inventory_local_users_password_last_change`
# * `inventory_local_users`
# * `inventory_local_users_password_empty`
{
  vars:
    linux::
      "local_users"
        slist => { @(cfe_autorun_inventory_local_users_discover.all_local_users) };

      "locked[$(local_users)]"
        string => "TRUE",
        ifvarclass => "$(cfe_autorun_inventory_local_users_discover.all_local_users_canonified_map[$(local_users)])_password_locked",
        comment => "We need to build an intermediary array of the locked users so
                    that we can report a unified list for inventory";

      "tmp_locked_users"
        #slist   => sort(getindices("locked"), "lex"),
        slist   => getindices("locked"),
        comment => "intermediary list so that we can filter out cf_null";

    have_locked_users::
      "locked_users"
         meta    => {
                     "inventory",
                     "attribute_name=Local users with locked accounts",
                     "derived_from=bundle:cfe_autorun_inventory_local_users_discover" },
         slist => { @(tmp_locked_users) },
        comment => "Report on the list of locked users so that they show up in
                    Mission Portal inventory.";

  classes:
    linux::
      "have_locked_users" expression => isgreaterthan(length("tmp_locked_users"), 0);

  reports:
    inform_mode|verbose_mode::
      "$(this.bundle): '$(locked_users)' account appears locked"
        ifvarclass => "have_locked_users";
}

bundle agent inventory_local_users_password_last_change
# @brief Inventory local user accounts and the days since their last password change
#
# This bundle inventories the number of days since a users password has been
# changed as discovered in `cfe_autorun_inventory_local_users_discover`.
#
# **Note:** Local uses without valid password hashes will not be considered.
#
# **See Also:**
# * `inventory_local_users`
# * `inventory_local_users_locked`
# * `inventory_local_users_password_empty`
{
  vars:
    linux::
      "now" int => now();
      "days_since_epoch" string => eval( "$(now)/24/3600", "math", "infix" );

      "all_local_users" slist => { @(cfe_autorun_inventory_local_users_discover.all_local_users) };
      "whitelist" slist => { @(inventory_control.inventory_local_users_password_last_change_whitelist) };

      "local_users"
        slist => intersection( "all_local_users", "whitelist" ),
        ifvarclass => "!disable_inventory_local_users_whitelist",
        handle => "cfe_autorun_inventory_local_users_discover_local_users_whitelist",
        comment => "Only filter the local users to report if the whitelist is requested";

      "local_users"
        slist => { @(all_local_users) },
        ifvarclass => "disable_inventory_local_users_whitelist",
        handle => "cfe_autorun_inventory_local_users_discover_local_users_all",
        comment => "If inventory of local users is not requested to be filtered
                    then we will proceed with all";

      "days_since_pw_change[$(local_users)]"
        string => format("%d", eval( "$(days_since_epoch)-$(cfe_autorun_inventory_local_users_discover.date_last_password_change[$(local_users)])", "math", "infix" ) ),
        ifvarclass => "$(cfe_autorun_inventory_local_users_discover.all_local_users_canonified_map[$(local_users)])_password_valid_hash",
        meta => {
                  "report",
                  "derived_from=bundle:cfe_autorun_inventory_local_users_discover",
                 };

    # We guard this so that we do not end up with an entry in the inventory interface that includes cf_null
    have_password_changes::
      "pw_change_date[$(local_users)]"
        #string => format("%d", eval( "$(now) - days_since_pw_change[$(local_users)])", "math", "infix" )),
        string => "$(cfe_autorun_inventory_local_users_discover.date_last_password_change[$(local_users)])",
        ifvarclass => "$(cfe_autorun_inventory_local_users_discover.all_local_users_canonified_map[$(local_users)])_password_valid_hash",
        meta => {
                  "inventory",
                  "attribute_name=Date $(local_users) password last changed",
                  "derived_from=bundle:cfe_autorun_inventory_local_users_discover",
                 };

  classes:
   "have_password_changes" expression => isgreaterthan(length("local_users"), 0);

  reports:
    inform_mode|verbose_mode::
      "$(this.bundle): Entered";
      "$(this.bundle): days since $(local_users) password change = $(days_since_pw_change[$(local_users)]"
        ifvarclass => "$(cfe_autorun_inventory_local_users_discover.all_local_users_canonified_map[$(local_users)])_password_valid_hash";
      "$(this.bundle): Have password change for $(local_users)";
      "$(this.bundle): Adding last password change date for '$(local_users)' to inventory since the user has a valid password hash and is not restricted by the whitelist"
        ifvarclass => "$(cfe_autorun_inventory_local_users_discover.all_local_users_canonified_map[$(local_users)])_password_valid_hash";
}

bundle agent inventory_local_users_password_empty
# @brief Inventory local user accounts that that have empty passwords
#
# This bundle inventories local user accounts that have empty passwords
# discovered in `cfe_autorun_inventory_local_users_discover`.
#
# **See Also:**
# * `inventory_local_users_password_last_change`
# * `inventory_local_users`
# * `inventory_local_users_locked`
{
  vars:
    linux::
      "local_users"
        slist => { @(cfe_autorun_inventory_local_users_discover.all_local_users) };

      "empty[$(local_users)]"
        string => "TRUE",
        ifvarclass => "$(cfe_autorun_inventory_local_users_discover.all_local_users_canonified_map[$(local_users)])_password_empty",
        comment => "We need to build an intermediary array of the empty users so
                    that we can report a unified list for inventory";

      "tmp_empty_users"
        #slist   => sort(getindices("locked"), "lex"),
        slist   => getindices("empty"),
        comment => "intermediary list so that we can filter out cf_null";

    # We guard this so that we do not end up with an entry in the inventory interface that includes cf_null
    have_empty_password_users::
      "empty_users"
        slist   => getindices("empty"),
        meta    => {
                     "inventory",
                     "attribute_name=Local users with empty passwords",
                     "derived_from=bundle:cfe_autorun_inventory_local_users_discover" },
        comment => "Report on the list of users with empty passwords so that they show up in
                    Mission Portal inventory. Empty passwords may be a security risk";

  classes:
    linux::
      "have_empty_password_users" expression => isgreaterthan(length("tmp_empty_users"), 0);

  reports:
    inform_mode|verbose_mode::
      "$(this.bundle): '$(empty_users)' password appears empty"
        ifvarclass => "have_empty_password_users";
}
body copy_from inventory_cmdb_copy_from
# @brief Copy from the CMDB source
{
    !cfe_inventory_cmdb_override_file::
      source      => "me.json";
      servers     => { "$(sys.policy_hub)" };
    cfe_inventory_cmdb_override_file::
      source      => "$(sys.inputdir)/me.json";
    any::
      compare     => "digest";
      encrypt     => "true";
      verify      => "true";
}

body classes inventory_scoped_classes_generic(scope, x)
# @brief Define `x` prefixed/suffixed with promise outcome
# **See also:** `scope`
#
# @param scope The scope in which the class should be defined
# @param x The unique part of the classes to be defined
#
# Copy of `scoped_classes_generic`, which see.
{
      scope => "$(scope)";
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_not_repaired", "$(x)_reached" };
}

body contain inventory_in_shell
# @brief run command in shell
#
# Copy of `in_shell`, which see.
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}
