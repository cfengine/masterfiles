#!/usr/bin/python

from __future__ import print_function

import pprint
import sys

TEST_COUNT = 0
PLATFORM_ARCH_32 = False

states = {
    "absent": {
        ( "64_bit", "1" ): False,
        ( "64_bit", "2" ): False,
        ( "32_bit", "1" ): False,
        ( "32_bit", "2" ): False,
    },
    "64_bit_1": {
        ( "64_bit", "1" ): True,
        ( "64_bit", "2" ): False,
        ( "32_bit", "1" ): False,
        ( "32_bit", "2" ): False,
    },
    "64_bit_2": {
        ( "64_bit", "1" ): False,
        ( "64_bit", "2" ): True,
        ( "32_bit", "1" ): False,
        ( "32_bit", "2" ): False,
    },
    "32_bit_1": {
        ( "64_bit", "1" ): False,
        ( "64_bit", "2" ): False,
        ( "32_bit", "1" ): True,
        ( "32_bit", "2" ): False,
    },
    "32_bit_2": {
        ( "64_bit", "1" ): False,
        ( "64_bit", "2" ): False,
        ( "32_bit", "1" ): False,
        ( "32_bit", "2" ): True,
    },
    "64_bit_1_32_bit_1": {
        ( "64_bit", "1" ): True,
        ( "64_bit", "2" ): False,
        ( "32_bit", "1" ): True,
        ( "32_bit", "2" ): False,
    },
    # These combinations are not possible, because different architecture
    # packages must be the same version.
    # "64_bit_1_32_bit_2": {
    #     ( "64_bit", "1" ): True,
    #     ( "64_bit", "2" ): False,
    #     ( "32_bit", "1" ): False,
    #     ( "32_bit", "2" ): True,
    # },
    # "64_bit_2_32_bit_1": {
    #     ( "64_bit", "1" ): False,
    #     ( "64_bit", "2" ): True,
    #     ( "32_bit", "1" ): True,
    #     ( "32_bit", "2" ): False,
    # },
    "64_bit_2_32_bit_2": {
        ( "64_bit", "1" ): False,
        ( "64_bit", "2" ): True,
        ( "32_bit", "1" ): False,
        ( "32_bit", "2" ): True,
    },
}


def header(test_count):
    print('''# THIS IS AN AUTOGENERATED TEST!
# DO NOT EDIT IT DIRECTLY!
#
# Instead, edit the_great_package_test_generator.py and use that to regenerate
# the test.
#
# Number of test cases: ''' + str(test_count) + '''
#
# If you want to run a specific test case, define a class with the name of that
# test, for example "from_absent_to_absent___promise_policy_absent_arch_64_bit".

body common control
{
    inputs => { "../../../dcs.cf.sub",
                "../../../../../$(sys.local_libdir)/packages.cf",
                "../../../../../$(sys.local_libdir)/commands.cf",
                "../../packages-info.cf.sub",
              };
    bundlesequence => { default($(this.promise_filename)) };
    package_module => "apt_get";
}

body package_module apt_get
{
    query_installed_ifelapsed => "0";
    query_updates_ifelapsed => "0";
}

bundle agent init
{
  meta:
      # TODO: Get RedHat support as well.
      "test_skip_needs_work" string => "!debian";
}

bundle agent log_test_case(msg)
{
  reports:
      "-------------------------------------"
        comment => "$(msg)_1";
      "$(msg)"
        comment => $(msg);
      "-------------------------------------"
        comment => "$(msg)_2";
}
''')

def get_possible_promises():
    # All the possible promises, expressed in terms of policy, architecture,
    # three versions (1, 2 or latest), and file to install.
    # P     = policy => "present"
    # D     = policy => "absent"
    # F     = File install
    # R     = Repo install
    # F64_1 = File to install is 64 bit and version 1
    # A64   = architecture = "64_bit"
    # V1    = version => "1"
    #
    # This is used to generate the promise structure. It does not include
    # impossible promises, such as installing a 64-bit file and mentioning
    # architecture => "32_bit".
    text_promises = [ "PF64_1     ",
                      "PF64_2     ",
                      "PF32_1     ",
                      "PF32_2     ",
                      "PF64_1A64  ",
                      "PF64_2A64  ",
                      "PF32_1A32  ",
                      "PF32_2A32  ",
                      "PF64_1   V1",
                      "PF64_2   V2",
                      "PF32_1   V1",
                      "PF32_2   V2",
                      "PF64_1A64V1",
                      "PF64_2A64V2",
                      "PF32_1A32V1",
                      "PF32_2A32V2",
                      "PR         ",
                      "PR    A64  ",
                      "PR    A32  ",
                      "PR       V1",
                      "PR       V2",
                      "PR       VL",
                      "PR    A64V1",
                      "PR    A32V1",
                      "PR    A64V2",
                      "PR    A32V2",
                      "PR    A64VL",
                      "PR    A32VL",
                      "D          ",
                      "D     A64  ",
                      "D     A32  ",
                      "D        V1",
                      "D        V2",
                      "D     A64V1",
                      "D     A32V1",
                      "D     A64V2",
                      "D     A32V2",
                    ]

    promises = []
    for text in text_promises:
        promise = {}
        if text[0] != "P":
            promise["policy"] = "absent"
        else:
            promise["policy"] = "present"

            if text[1] != "F":
                promise["type"] = "repo"
            else:
                promise["type"] = "file"

                if text[2:4] == "64":
                    promise["file_arch"] = "64_bit"
                else:
                    promise["file_arch"] = "32_bit"

                if text[5] == "1":
                    promise["file_version"] = "1"
                else:
                    promise["file_version"] = "2"

        if text[6:9] == "A64":
            promise["arch"] = "64_bit"
        elif text[6:9] == "A32":
            promise["arch"] = "32_bit"

        if text[9:11] == "VL":
            promise["version"] = "latest"
        elif text[9] == "V":
            promise["version"] = text[10]

        promises.append(promise)

    return promises


# Given the transitions between the two version, determine if the change of one
# architecture package will trigger a change in the other. Only one of the two
# inputs can be different, but the returned value may cause both to be
# different. This is only relevant for "repo" style promises, since "file"
# promises will never touch more than one package at a time.
def resolve_arch_conflicts(from_64, from_32, to_64, to_32):
    if from_64 != to_64:
        if from_32 != "0":
            if to_64 >= from_32:
                to_32 = to_64
            else:
                to_32 = "0"

    elif from_32 != to_32:
        if from_64 != "0":
            if to_32 >= from_64:
                to_64 = to_32
            else:
                to_64 = "0"

    return to_64, to_32


# Simulate, with the given promise, what the state of the system would be,
# if we started from the versions in from_64 and from_32.
def simulate_promise(promise, from_64, from_32):
    to_64 = from_64
    to_32 = from_32

    arch, version = promise.get('arch'), promise.get('version')
    if promise["policy"] == "present":
        if promise["type"] == "repo":
            if version == "latest":
                version = "2"

            if arch == "64_bit":
                if version:
                    to_64 = version
                elif from_64 == "0":
                    to_64 = "2"

                to_64, to_32 = resolve_arch_conflicts(from_64, from_32, to_64, to_32)

            elif arch == "32_bit":
                if version:
                    to_32 = version
                elif from_32 == "0":
                    to_32 = "2"

                to_64, to_32 = resolve_arch_conflicts(from_64, from_32, to_64, to_32)

            elif version:

                if from_64 != "0" or (from_64 == "0" and from_32 == "0"):
                    to_64 = version

                if from_32 != "0":
                    to_32 = version

            elif from_64 == "0" and from_32 == "0":
                to_64 = "2"

        else:
            # Todo: Errors when file doesn't match arch/version?
            if promise["file_arch"] == "64_bit":
                to_64 = promise["file_version"]
            else:
                to_32 = promise["file_version"]

    else:
        if arch == "64_bit":
            if not version or version == from_64:
                to_64 = "0"
        elif arch == "32_bit":
            if not version or version == from_32:
                to_32 = "0"
        else:
            if version:
                if version == from_64:
                    to_64 = "0"
                if version == from_32:
                    to_32 = "0"
            else:
                to_64 = "0"
                to_32 = "0"

    return to_64, to_32


# Calculate all possible transitions from from_state, to to_state.
def calc_transitions(from_state, to_state):
    from_64 = "0"
    if states[from_state][("64_bit", "1")]:
        from_64 = "1"
    elif states[from_state][("64_bit", "2")]:
        from_64 = "2"

    from_32 = "0"
    if states[from_state][("32_bit", "1")]:
        from_32 = "1"
    elif states[from_state][("32_bit", "2")]:
        from_32 = "2"

    to_64 = "0"
    if states[to_state][("64_bit", "1")]:
        to_64 = "1"
    elif states[to_state][("64_bit", "2")]:
        to_64 = "2"

    to_32 = "0"
    if states[to_state][("32_bit", "1")]:
        to_32 = "1"
    elif states[to_state][("32_bit", "2")]:
        to_32 = "2"

    promise_candidates = get_possible_promises()
    valid_promises = []

    for promise in promise_candidates:
        result = simulate_promise(promise, from_64, from_32)
        if result[0] == to_64 and result[1] == to_32:
            valid_promises.append(promise)

    return valid_promises


# Calculate all possible transitions from all states to all other states,
# including the same state.
def calc_all_transitions():
    transitions = {}
    for from_state in states:
        for to_state in states:
            transitions[(from_state, to_state)] = calc_transitions(from_state, to_state)

    return transitions


def formatted_version(version):
    if version == "latest":
        return "latest"
    else:
        return "$(p.version[" + version + "])"


# Write one test case, using one promise to go from one state to another (or the
# same) state.
# This function is quite hard to read because of all the quoting going on, it
# might be easier to look at the output it produces.
def make_test(current_count, total_test_count, from_state, to_state, transition, test_handle, warn_only):
    print('''bundle agent ''' + test_handle + '''
{
  methods:
      "''' + test_handle + '''_start_msg"
        usebundle => log_test_case("''' + str((current_count * 100) / total_test_count) + '''%: Starting test case \\"''' + test_handle + '''\\"");
      "''' + test_handle + '''_init"
        usebundle => ''' + test_handle + '''_init;
      "''' + test_handle + '''_test"
        usebundle => ''' + test_handle + '''_test;
      "''' + test_handle + '''_check"
        usebundle => ''' + test_handle + '''_check;
      "''' + test_handle + '''_finish_msg"
        usebundle => log_test_case("''' + str((current_count * 100) / total_test_count) + '''%: Finished test case \\"''' + test_handle + '''\\"");
}

bundle agent ''' + test_handle + '''_init
{
  methods:
      "clear_packages" usebundle => clear_packages("''' + test_handle + '''");
      "clear_package_cache" usebundle => clear_package_cache("''' + test_handle + '''");''')
    for arch in ["64_bit", "32_bit"]:
        for version in ["1", "2"]:
            if states[from_state][(arch, version)]:
                print("      \"install_package\" usebundle => install_package($(p.name[1]), "
                      + formatted_version(version) + ", $(p." + arch + "), \"" + test_handle + "\");")
    print("}\n")

    print('''bundle agent ''' + test_handle + '''_test
{
  packages:''')
    if transition["policy"] == "absent" or transition["type"] == "repo":
        print("      \"$(p.name[1])\"")
    else:
        print("      \"$(p.package[1][" + transition["file_version"] + "][" + transition["file_arch"] + "])\"")
    print("        policy => \"" + transition["policy"] + "\"")
    if transition.get("arch"):
        print("      , architecture => \"$(p." + transition["arch"] + ")\"")
    if transition.get("version"):
        print("      , version => \"" + formatted_version(transition["version"]) + "\"")
    if warn_only:
        print("      , action => warn_only")
    print("      , classes => classes_generic(\"" + test_handle + "___class\")")
    print('''      ;
}

bundle agent ''' + test_handle + '''_check
{
  classes:
      "''' + test_handle + '''___correct_classes"''')
    if from_state == to_state:
        print("        expression => \"" + test_handle + "___class_kept.!" + test_handle + "___class_repaired.!" + test_handle + "___class_failed\";")
    elif warn_only:
        print("        expression => \"!" + test_handle + "___class_kept.!" + test_handle + "___class_repaired." + test_handle + "___class_failed\";")
    else:
        print("        expression => \"!" + test_handle + "___class_kept." + test_handle + "___class_repaired.!" + test_handle + "___class_failed\";")

    if warn_only:
        file_state_to_check = from_state
    else:
        file_state_to_check = to_state
    for arch in ["64_bit", "32_bit"]:
        for version in ["1", "2"]:
            print("      \"" + arch + "_" + version + "\"")
            if states[file_state_to_check][(arch, version)]:
                print("        expression => fileexists(\"$(p.file[1][" + version + "][" + arch + "])\");")
            else:
                print("        not => fileexists(\"$(p.file[1][" + version + "][" + arch + "])\");")
    print('''      "''' + test_handle + '''_ok"
        scope => "namespace",
        and => {''')
    for arch in ["64_bit", "32_bit"]:
        for version in ["1", "2"]:
            print("          \"" + arch + "_" + version + "\",")
    print('''          "''' + test_handle + '''___correct_classes"
        };
''')

    print('''  reports:
    !''' + test_handle + '''_ok::
      "FAILED: ''' + test_handle + '''";
    ''' + test_handle + '''_ok::
      "PASS: ''' + test_handle + '''";
  commands:
    !''' + test_handle + '''_ok::
      "$(G.echo) 'Contents of \\"/$(p.name[1])*\\"' && $(G.ls) /$(p.name[1])*"
        contain => in_shell;

  reports:''')

    if from_state != to_state and warn_only:
        print('''    !''' + test_handle + '''___class_failed::
      "Class was not set, but should be: ''' + test_handle + '''___class_failed";''')
    else:
        print('''    ''' + test_handle + '''___class_failed::
      "Class was set, but should not be: ''' + test_handle + '''___class_failed";''')

    if from_state != to_state:
        print('''    ''' + test_handle + '''___class_kept::
      "Class was set, but should not be: ''' + test_handle + '''___class_kept";''')
    else:
        print('''    !''' + test_handle + '''___class_kept::
      "Class was not set, but should be: ''' + test_handle + '''___class_kept";''')

    if from_state != to_state and not warn_only:
        print('''    !''' + test_handle + '''___class_repaired::
      "Class was not set, but should be: ''' + test_handle + '''___class_repaired";''')
    else:
        print('''    ''' + test_handle + '''___class_repaired::
      "Class was set, but should not be: ''' + test_handle + '''___class_repaired";''')

    print('''}
''')


# Print the main test bundles.
def main_bundles(test_handles):
    print('''bundle agent test
{
  classes:
      "specific_test_case_specified" or => {''')
    for handle in test_handles:
        print("          \"" + handle + "\",")
    print('''      };
      "run_all_tests"
        not => "specific_test_case_specified",
        scope => "namespace";

  methods:''')
    for handle in test_handles:
        print("    run_all_tests|" + handle + "::")
        print("      \"" + handle + "\"\n        usebundle => " + handle + ";")
    print("}")

    print('''bundle agent check
{
  classes:
      "ok" and => {''')
    # Enable test to pass even when running only a sub test.
    for handle in test_handles:
        print("          \"" + handle + "_ok|(!run_all_tests.!" + handle + ")\",")
    print('''        };

  reports:
    !ok::
      "$(this.promise_filename) FAIL";
    ok::
      "$(this.promise_filename) Pass";
}''')



transitions = calc_all_transitions()
test_count = 0
test_handles = []
current_count = 0
# One pass to count tests, one pass to actually output them.
for op in ["count", "do"]:
    if op == "do":
        header(test_count)
    for i in transitions:
        for j in transitions[i]:
            if op == "count":
                test_count += 1
            else:
                current_count += 1
                test_handle = "from_" + i[0] + "_to_" + i[1] + "___promise_" + "_".join([k + "_" + j[k] for k in j])
                test_handles.append(test_handle)
                make_test(current_count, test_count, i[0], i[1], j, test_handle, False)

            # Cut down on testing time by not testing "warn_only" together with
            # equal states. "warn_only" has no effect there, since there is no
            # change to begin with.
            if i[0] == i[1]:
                continue

            if op == "count":
                test_count += 1
            else:
                current_count += 1
                test_handle += "_warn_only"
                test_handles.append(test_handle)
                make_test(current_count, test_count, i[0], i[1], j, test_handle, True)

main_bundles(test_handles)
