###############################################################################
#
#   update.cf - Basic Update Policy
#
###############################################################################

body common control
{
      bundlesequence => {
                          "update_def",
                          "u_cfengine_enterprise",
                          @(u_cfengine_enterprise.def),
                          "mpf_update",

      };

      version => "update.cf $(update_def.current_version)";

      inputs => {
                  @(cfengine_update_controls.update_def_inputs),
                  @(update_def.inputs),
                  "cfe_internal/update/update_bins.cf",
                  "cfe_internal/update/cfe_internal_dc_workflow.cf",
                  "cfe_internal/update/cfe_internal_local_git_remote.cf",
                  "cfe_internal/update/cfe_internal_update_from_repository.cf",
                  "cfe_internal/update/update_policy.cf",
                  "cfe_internal/update/update_processes.cf"
      };
}

#############################################################################

bundle agent mpf_update
# @brief Masterfiles Policy Framework Update Policy
#
# @description These policies are related to ensuring the environment is
# configured properly before a policy run. This includes publishing policy with
# the masterfiles-stage tooling, making sure that $(sys.inputdir) is updated
# from its upstream masterfiles, updating CFEngine packages, and ensuring the
# necessary CFEngine components are running,
{
  vars:
      "sorted_update_bundlesequence_end"
        meta => { "defvar" },
        slist => sort( @(def.update_bundlesequence_end), "lex" );

      "num_custom_bundles" int => length( "sorted_update_bundlesequence_end" );

  classes:
      # TODO After 3.10 is no longer supported compress into a single promise
      # nesting functions
      "_have_custom_update_bundles"
        expression => isgreaterthan( $(num_custom_bundles), 0);

  methods:

      "Design Center"
        usebundle => cfe_internal_dc_workflow,
        comment => "Policy related to the design center workflow. This includes
                    publishing policy changes from hubs using the
                    masterfiles-stage tooling";

      "CFEngine Binaries"
        usebundle => cfe_internal_bins,
        comment => "Policy to manage binary and library permissions and symlinks
                    into common PATH";

      "Policy Inputs"
        usebundle => cfe_internal_update_policy,
        comment => "Policy related to updating $(sys.inputdir) from published
                    masterfiles";

      "CFEngine Package"
        usebundle => cfe_internal_update_bins,
        comment => "Policy to manage the internal binary upgrade process.";

      "CFEngine Processes"
        usebundle => cfe_internal_update_processes,
        comment => "Policy to make sure the appropriate CFEngine components are
                    running.";

    _have_custom_update_bundles::
      "Custom Update Policy"
        usebundle => $(sorted_update_bundlesequence_end),
        comment => "We want users to be able to easily define additional bundles
                    to be actuated as part of the update policy";
}

bundle common cfengine_update_controls
{
  vars:
    # 3.6 uses the split controls
    cfengine_3_6::
      "update_def_inputs"
        slist => {
                   "controls/$(sys.cf_version_major).$(sys.cf_version_minor)/update_def.cf",
                   "controls/$(sys.cf_version_major).$(sys.cf_version_minor)/update_def_inputs.cf",
                 };

    # 3.7+ uses the re-unified controls
    !cfengine_3_6::
       "update_def_inputs"
        slist => {
                   "controls/update_def.cf",
                   "controls/update_def_inputs.cf",
                 };

  reports:
    DEBUG|DEBUG_cfengine_update_controls::
      "DEBUG $(this.bundle): update def inputs='$(update_def_inputs)'";
}

body agent control
{
      ifelapsed => "1";
      skipidentify => "true";
}

#############################################################################

body classes u_kept_successful_command
# @brief Set command to "kept" instead of "repaired" if it returns 0
{
      kept_returncodes => { "0" };
      failed_returncodes => { "1" };
}
