############################################################################
#  Copyright (C) CFEngine AS
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License LGPL as published by the
#  Free Software Foundation; version 3.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  To the extent this program is licensed as part of the Enterprise
#  versions of CFEngine, the applicable Commercial Open Source License
#  (COSL) may apply to this file if you as a licensee so wish it. See
#  included file COSL.txt.
###########################################################################
#
# CFEngine Community Open Promise-Body Library
#
# This initiative started by CFEngine promotes a
# standardized set of names and promise specifications
# for template functionality within CFEngine 3.
#
# The aim is to promote an industry standard for
# naming of configuration patterns, leading to a
# de facto middleware of standardized syntax.
#
# Names should be intuitive and parameters should be
# minimal to assist readability and comprehensibility.

# Contributions to this file are voluntarily given to
# the cfengine community, and are moderated by CFEngine.
# No liability or warranty for misuse is implied.
#
# If you add to this file, please try to make the
# contributions "self-documenting". Comments made
# after the bundle/body statement are retained in
# the online docs
#

# For CFEngine Core: 3.6.0 to 3.6.x
# Paths bundle (used by other bodies)

###################################################
# If you find CFEngine useful, please consider    #
# purchasing a commercial version of the software.#
###################################################

bundle agent paths
# @brief Defines an array `path` with common paths to standard binaries,
# and classes for defined and existing paths.
#
# If the current platform knows that binary XYZ should be present,
# `_stdlib_has_path_XYZ` is defined. Furthermore, if XYZ is actually present
# (i.e. the binary exists) in the expected location, `_stdlib_path_exists_XYZ` is
# defined.
#
# **Example:**
#
# ```cf3
# bundle agent repair_newlines(filename)
# {
# commands:
#   _stdlib_path_exists_sed::
#      “$(path[sed])”
#        args => “-i 's/^M//' $(filename)”
# }
# ```
{
  vars:
      "PATH"
        slist => {
                    "/var/cfengine/bin",
                    "/usr/local/sbin",
                    "/usr/local/bin",
                    "/usr/sbin",
                    "/usr/bin",
                    "/sbin",
                    "/bin",
                  };

      "REV_PATH"
        slist => reverse("PATH"),
        comment => "We reverse the path so that the first listed path is what wins";

      "SEARCH_PATH" string => join(" ", "REV_PATH");

      "paths" slist => getindices("paths.path");
      "c_paths_map[$(paths)]" string => canonify("$(paths)");

      # Avoid *some* errors about illegal variable names, specifically those containing `-`.
      # Unfortunately some packages contain other special characters that are
      # invalid variable names. Specifically those with '+', for example
      # 'c++filt' and 'mklost+found' Probably thise should be canonified at the module level of this bundle.
      "$(c_paths_map[$(paths)])" string => "$(path[$(paths)])";
      "paths_cache" string => "$(sys.workdir)/state/paths.cache";
      "software_packages_cache" string => "$(sys.workdir)/state/software_packages.csv";

  classes:
      # This class definition could be deprecated as paths are only defined if they exist anyway.
      "_stdlib_has_path_$(paths)" expression => "any";
      "_stdlib_path_exists_$(paths)" expression => "any";

      "_refresh_paths_cache" expression => "software_packages_csv_repaired";
      "have_paths_cache" expression => isplain($(paths_cache));

  files:
      "$(software_packages_cache)"
        changes => detect_content_using("md5"),
        classes => scoped_classes_generic("bundle", "software_packages_csv");

  # using a command means that this cannot be a common bundle. Perhaps
  # reconisder using findfiles, or this bundle needs to be listed first in the
  # bundlesequence.

  commands:
    _refresh_paths_cache|!have_paths_cache::
      # I used find because findfiles was slow and a bit clunky. Unfortunately
      # find is not necessarily available on every platform. Additionally I was
      # able to format the find output in a modual protocal format so it can be
      # easily cached.
      "/usr/bin/find"
        args =>"$(SEARCH_PATH) -maxdepth 1 -type f -executable -fprintf $(paths_cache) '^context=paths\n=path[%f]=%p\n'",
        comment => "Format the find commands output so that we end up with an
                    array of bins and paths for easy reference from within
                    policy.";

      have_paths_cache::
        "/bin/cat"
          args => "$(paths_cache)",
          module => "true";

  reports:
    DEBUG|DEBUG_paths::
      "$(paths) = $(path[$(paths)])";
}
